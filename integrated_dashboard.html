<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¾è‚¡æƒ…ç»ªçœ‹æ¿ - ç»¼åˆä»ªè¡¨ç›˜</title>
    <link rel="stylesheet" href="chart.min.css">
    <style>
        :root {
            --optimistic-color: rgba(39, 174, 96, 0.7);
            --optimistic-light: rgba(39, 174, 96, 0.3);
            --neutral-color: rgba(243, 156, 18, 0.7);
            --neutral-light: rgba(243, 156, 18, 0.3);
            --pessimistic-color: rgba(231, 76, 60, 0.7);
            --pessimistic-light: rgba(231, 76, 60, 0.3);
            --missing-color: rgba(149, 165, 166, 0.7);
            --missing-light: rgba(149, 165, 166, 0.3);
            --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --card-radius: 10px;
            --card-padding: 20px;
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .section {
            background-color: white;
            border-radius: var(--card-radius);
            box-shadow: var(--card-shadow);
            padding: var(--card-padding);
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.5em;
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        /* æƒ…ç»ªåˆ†å¸ƒè¶‹åŠ¿å›¾æ ·å¼ */
        .chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }

        /* æƒ…ç»ªç»Ÿè®¡å¡ç‰‡æ ·å¼ */
        .stats-cards {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            flex: 1;
            min-width: 200px;
            background-color: white;
            border-radius: var(--card-radius);
            box-shadow: var(--card-shadow);
            padding: 15px;
            text-align: center;
            display: flex;
            flex-direction: column;
        }

        .stat-card h3 {
            margin-top: 0;
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-card .trend {
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .stat-card .mini-chart {
            height: 60px;
            margin-top: auto;
            padding: 5px 0;
        }

        .trend-up {
            color: var(--optimistic-color);
        }

        .trend-neutral {
            color: var(--neutral-color);
        }

        .trend-down {
            color: var(--pessimistic-color);
        }

        /* æŒ‡æ ‡å¡ç‰‡ç½‘æ ¼æ ·å¼ */
        .indicators-section {
            margin-top: 40px;
        }

        .indicators-grid {
            display: grid;
            /* ä¿®æ”¹ä¸ºä¸¤åˆ—ï¼Œæ¯åˆ—æœ€å°å®½åº¦ä¸º 450pxï¼Œå æ®å¯ç”¨ç©ºé—´çš„ 1 ä»½ */
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .indicator-card {
            background-color: white;
            border-radius: var(--card-radius);
            box-shadow: var(--card-shadow);
            padding: 15px;
            display: flex;
            flex-direction: column;
            min-height: 300px; /* å¢åŠ å¡ç‰‡é«˜åº¦20% (250px * 1.2 = 300px) */
            cursor: pointer; /* æ·»åŠ æŒ‡é’ˆæ ·å¼ï¼Œè¡¨ç¤ºå¯ç‚¹å‡» */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        /* æ ¹æ®æƒ…ç»ªåˆ¤æ–­è®¾ç½®å¡ç‰‡å·¦è¾¹æ¡†è‰² */
        .indicator-card.optimistic {
            border-left: 4px solid var(--optimistic-color);
        }
        
        .indicator-card.neutral {
            border-left: 4px solid var(--neutral-color);
        }
        
        .indicator-card.pessimistic {
            border-left: 4px solid var(--pessimistic-color);
        }
        
        .indicator-card.missing {
            border-left: 4px solid var(--missing-color);
        }
        
        .indicator-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .indicator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .indicator-name {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
        }

        .indicator-sentiment {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .sentiment-optimistic {
            background-color: var(--optimistic-light);
            color: #27ae60;
        }

        .sentiment-neutral {
            background-color: var(--neutral-light);
            color: #f39c12;
        }

        .sentiment-pessimistic {
            background-color: var(--pessimistic-light);
            color: #e74c3c;
        }

        .sentiment-missing {
            background-color: var(--missing-light);
            color: #7f8c8d;
        }

        .indicator-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 10px 0;
            color: #2c3e50;
        }
        
        .value-na {
            color: #999;
            font-size: 1.5rem;
            font-style: italic;
        }
        
        .indicator-explanation {
            margin-top: 10px;
            font-size: 0.9em;
            color: #34495e;
            line-height: 1.4;
            flex-grow: 1;
            overflow-y: auto;
            max-height: 100px;
        }
        
        .threshold-explanation {
            margin-top: 5px;
            font-size: 0.8em;
            color: #7f8c8d;
            font-style: italic;
            border-top: 1px dashed #ecf0f1;
            padding-top: 8px;
        }
        
        .detailed-explanation {
            font-size: 0.85em;
            color: #34495e;
            margin: 10px 0;
            line-height: 1.5;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid #3498db;
            max-height: 300px;
            overflow-y: auto;
        }

        .mini-chart {
            height: 150px; /* å¢åŠ å›¾è¡¨é«˜åº¦ */
            margin-top: auto;
            border-radius: 4px;
            overflow: hidden;
            padding: 10px 5px 5px 5px;
            border-top: 1px solid #eee;
        }
        
        /* åˆ†ç±»æ ‡é¢˜æ ·å¼ */
        .category-title {
            margin: 30px 0 20px 0;
            padding: 15px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .category-title h2 {
            margin: 0;
            color: white;
            font-size: 1.3em;
            font-weight: 600;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .category-title:first-child {
            margin-top: 0;
        }
        
        /* åˆ†ç±»æŒ‡æ ‡å®¹å™¨æ ·å¼ */
        .category-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        /* å“åº”å¼å¸ƒå±€ */
        /* åª’ä½“æŸ¥è¯¢ï¼Œåœ¨å°å±å¹•ä¸Šä¾ç„¶ä¿æŒå•åˆ— */
        @media (max-width: 960px) { /* è°ƒæ•´æ–­ç‚¹ï¼Œé€‚é…ä¸¤åˆ—å¸ƒå±€ */
            .indicators-grid {
                grid-template-columns: 1fr; /* å°å±å¹•ä¸Šå˜ä¸ºå•åˆ— */
            }
            
            .category-indicators {
                grid-template-columns: 1fr; /* å°å±å¹•ä¸Šåˆ†ç±»æŒ‡æ ‡ä¹Ÿå˜ä¸ºå•åˆ— */
            }
            
            .stats-cards {
                flex-direction: column;
            }

            .stat-card {
                width: 100%;
            }
        }
        
        @media (max-width: 600px) {
            .category-title {
                margin: 20px 0 15px 0;
                padding: 12px 15px;
            }
            
            .category-title h2 {
                font-size: 1.1em;
            }
            
            .category-indicators {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š ç¾è‚¡æƒ…ç»ªçœ‹æ¿</h1>
            <p>ç»¼åˆåˆ†æç¾è‚¡å¸‚åœºæƒ…ç»ªæŒ‡æ ‡</p>
            <p id="lastUpdate">æœ€åæ›´æ–°: 2025-07-15</p>
        </div>

        <!-- æƒ…ç»ªåˆ†å¸ƒè¶‹åŠ¿å›¾ -->
        <div class="section">
            <h2 class="section-title">æƒ…ç»ªåˆ†å¸ƒè¶‹åŠ¿</h2>
            <div class="chart-container">
                <canvas id="sentimentChart"></canvas>
            </div>
        </div>

        <!-- æƒ…ç»ªç»Ÿè®¡å¡ç‰‡ -->
        <div class="section">
            <h2 class="section-title">æƒ…ç»ªæŒ‡æ ‡ç»Ÿè®¡</h2>
            <div class="stats-cards">
                <div class="stat-card">
                    <h3>ä¹è§‚æŒ‡æ ‡</h3>
                    <div class="value" id="optimisticValue">0</div>
                    <div class="trend" id="optimisticTrend">è¶‹åŠ¿: --</div>
                    <div class="mini-chart">
                        <canvas id="optimisticChart"></canvas>
                    </div>
                </div>
                <div class="stat-card">
                    <h3>ä¸­æ€§æŒ‡æ ‡</h3>
                    <div class="value" id="neutralValue">0</div>
                    <div class="trend" id="neutralTrend">è¶‹åŠ¿: --</div>
                    <div class="mini-chart">
                        <canvas id="neutralChart"></canvas>
                    </div>
                </div>
                <div class="stat-card">
                    <h3>æ‚²è§‚æŒ‡æ ‡</h3>
                    <div class="value" id="pessimisticValue">0</div>
                    <div class="trend" id="pessimisticTrend">è¶‹åŠ¿: --</div>
                    <div class="mini-chart">
                        <canvas id="pessimisticChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- æŒ‡æ ‡å¡ç‰‡ç½‘æ ¼ -->
        <div class="section indicators-section">
            <h2 class="section-title">æƒ…ç»ªæŒ‡æ ‡è¯¦æƒ…</h2>
            <div class="indicators-grid" id="indicatorsGrid">
                <!-- æŒ‡æ ‡å¡ç‰‡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <!-- å¼•å…¥Chart.jsåº“å’ŒAnnotationsæ’ä»¶ -->
    <script src="chart.min.js"></script>
    <script src="chartjs-plugin-annotation.min.js"></script>
    <script>
        // æ ¼å¼åŒ–æ—¥æœŸå‡½æ•°
        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            
            if (dateString.includes('/')) {
                return dateString;
            } else if (dateString.includes('-')) {
                const parts = dateString.split('-');
                if (parts.length === 3) {
                    return `${parseInt(parts[1])}/${parseInt(parts[2])}`;
                }
            }
            
            try {
                const date = new Date(dateString);
                if (!isNaN(date.getTime())) {
                    return `${date.getMonth() + 1}/${date.getDate()}`;
                }
            } catch (e) {
                // æ—¥æœŸè§£æå¤±è´¥ï¼Œè¿”å›åŸå­—ç¬¦ä¸²
            }
            
            return dateString;
        }

        // ä»CSVæ•°æ®ç”Ÿæˆæƒ…ç»ªåˆ†å¸ƒæ•°æ®
        function generateSentimentDistribution(parsedRows) {
            console.log('generateSentimentDistributionæ¥æ”¶åˆ°çš„æ•°æ®è¡Œæ•°:', parsedRows.length);
            console.log('ç¬¬ä¸€è¡Œæ•°æ®:', parsedRows[0]);
            
            // è·å–æ‰€æœ‰æ—¥æœŸå¹¶æ’åº
            const allDates = parsedRows.map(row => row[0]);
            console.log('æ‰€æœ‰æ—¥æœŸ:', allDates.slice(0, 10));
            
            const dates = [...new Set(allDates)]
                .filter(date => date && date.match(/^\d{4}-\d{2}-\d{2}$/))
                .sort();
            
            console.log('è¿‡æ»¤åçš„æ—¥æœŸ:', dates);
            
            const distribution = dates.map(date => {
                const dayData = parsedRows.filter(row => row[0] === date && row[1] && row[1] !== 'æ¿å—ETFæµå‘');
                
                let optimistic = 0, neutral = 0, pessimistic = 0, missing = 0;
                
                dayData.forEach(row => {
                    const sentiment = row[2]; // åˆ¤æ–­ç»“æœåˆ—
                    switch (sentiment) {
                        case 'ä¹è§‚': optimistic++; break;
                        case 'ä¸­æ€§': neutral++; break;
                        case 'æ‚²è§‚': pessimistic++; break;
                        case 'æ‚²è§‚/è­¦ç¤º': pessimistic++; break;
                        default: missing++; break;
                    }
                });
                
                return { date, optimistic, neutral, pessimistic, missing };
            });
            
            return { overall_sentiment_distribution: distribution };
        }

        // CSVè§£æå‡½æ•°
        function parseCsvLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            if (!line || line.trim() === '') return [];
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            
            return result.map(field => {
                if (field.startsWith('"') && field.endsWith('"')) {
                    return field.substring(1, field.length - 1);
                }
                return field;
            });
        }

        // åŠ è½½æŒ‡æ ‡è¯¦æƒ…æ•°æ®
            async function loadIndicatorsData() {
                try {
                    const response = await fetch('enhanced_processed_sentiment_data.csv');
                    
                    if (!response.ok) {
                        throw new Error(`HTTPé”™è¯¯: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    
                    if (lines.length < 2) {
                        throw new Error('æ•°æ®æ–‡ä»¶ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯');
                    }
                    
                    const parsedRows = lines.slice(1).map(line => parseCsvLine(line));
                    const dates = [...new Set(parsedRows.map(row => row[0]))].filter(date => date && date.match(/^\d{4}-\d{2}-\d{2}$/)).sort();
                    const latestDate = dates[dates.length - 1];
                    
                    const currentStateData = parsedRows.filter(row => row[0] === latestDate && row[1] && row[1] !== 'æ¿å—ETFæµå‘');
                    
                    let latestDataDate = latestDate;
                    
                    const indicators = currentStateData.map(row => ({
                        name: row[1] || 'æœªçŸ¥æŒ‡æ ‡',
                        value: row[4] || 'N/A',
                        sentiment: getSentimentType(row[2]),
                        explanation: row[6] || 'æ— è§£é‡Š',
                        detailedExplanation: row[6] || '',
                        thresholdExplanation: getThresholdExplanationForIndicator(row[1]),
                        dataDate: row[0]
                    }));
                    
                    // ä¸ºæ¯ä¸ªæŒ‡æ ‡æ·»åŠ å†å²æ•°æ®
                    for (const indicator of indicators) {
                        // è·å–è¯¥æŒ‡æ ‡çš„æ‰€æœ‰å†å²æ•°æ®
                        const indicatorHistory = parsedRows
                            .filter(row => row.length >= 5 && row[1] === indicator.name)
                            .map(row => {
                                // å°è¯•è·å–çœŸå®æ•°å€¼ï¼Œå¦‚æœä¸æ˜¯æœ‰æ•ˆæ•°å­—åˆ™ä½¿ç”¨æƒ…ç»ªå¾—åˆ†
                                let value;
                                let rawValue = row[4]; // ä¿å­˜åŸå§‹å€¼ï¼ˆç¬¬4åˆ—ï¼šæ•°å€¼æ•°æ®ï¼‰
                                
                                if (row[4] && !isNaN(parseFloat(row[4]))) {
                                value = parseFloat(row[4]); // ä½¿ç”¨çœŸå®æ•°å€¼æ•°æ®ï¼ˆç¬¬4åˆ—ï¼‰
                            } else if (row[3] && !isNaN(parseFloat(row[3]))) {
                                value = parseFloat(row[3]); // ä½¿ç”¨æƒ…ç»ªå¾—åˆ†ï¼ˆç¬¬3åˆ—ï¼‰
                                } else {
                                    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°å€¼ï¼Œè·³è¿‡è¿™ä¸ªæ•°æ®ç‚¹ï¼ˆä¸åˆ›å»ºé»˜è®¤å€¼ï¼‰
                                    return null;
                                }
                                
                                return {
                                    date: row[0],
                                    value: value,
                                    rawValue: row[4] || null,
                                    sentiment: getSentimentType(row[2])
                                };
                            })
                            .filter(item => item !== null) // è¿‡æ»¤æ‰nullå€¼ï¼ˆç¼ºå¤±æ•°æ®çš„æ•°æ®ç‚¹ï¼‰
                            .sort((a, b) => new Date(a.date) - new Date(b.date));
                        
                        if (indicatorHistory.length > 0) {
                            indicator.data = indicatorHistory;
                            
                            if (indicator.value === 'N/A' || indicator.value === 'n/a' || !indicator.value || indicator.value.trim() === '') {
                                // ä»å†å²æ•°æ®ä¸­æ‰¾åˆ°æœ€è¿‘ä¸€ä¸ªæœ‰æ•ˆçš„å®Œæ•´æ•°æ®
                                if (indicatorHistory.length > 1) {
                                    // ä»all_sentiment_data.csvä¸­æ‰¾åˆ°å‰ä¸€ä¸ªæœ‰æ•ˆæ—¥æœŸçš„å®Œæ•´æ•°æ®
                                    const dates = [...new Set(parsedRows.map(row => row[0]))].sort();
                                    let validDateIndex = dates.length - 2; // ä»å€’æ•°ç¬¬äºŒä¸ªæ—¥æœŸå¼€å§‹æŸ¥æ‰¾
                                    
                                    while (validDateIndex >= 0) {
                                        const validDate = dates[validDateIndex];
                                        const validDateData = parsedRows.find(row => 
                                            row[0] === validDate && 
                                            row[1] === indicator.name && 
                                            row[4] && row[4] !== 'N/A' && row[4] !== 'n/a' && row[4].trim() !== ''
                                        );
                                        
                                        if (validDateData) {
                                            // ä½¿ç”¨å‰ä¸€ä¸ªæœ‰æ•ˆæ—¥æœŸçš„å®Œæ•´æ•°æ®æ›¿æ¢å½“å‰æŒ‡æ ‡çš„æ‰€æœ‰æ•°æ®
                                            indicator.value = validDateData[4]; // æ•°å€¼ï¼ˆç¬¬4åˆ—ï¼‰
                                            indicator.sentiment = getSentimentType(validDateData[2]); // æƒ…ç»ªåˆ¤æ–­
                                            
                                            // æ›´æ–°è§£é‡Šä¿¡æ¯
                                            indicator.explanation = validDateData[6] || 'æ— è§£é‡Š'; // å½“å‰çŠ¶æ€è§£è¯»ä½œä¸ºæ¯æ—¥æœ€æ–°æŒ‡æ ‡è§£è¯»ï¼ˆç¬¬6åˆ—ï¼‰
                                            indicator.detailedExplanation = validDateData[6] || ''; // å½“å‰çŠ¶æ€è§£è¯»ï¼ˆç¬¬6åˆ—ï¼‰
                                            indicator.thresholdExplanation = getThresholdExplanationForIndicator(indicator.name); // å§‹ç»ˆä½¿ç”¨ç¡¬ç¼–ç çš„åˆ¤æ–­æ ‡å‡†
                                            indicator.previousDataDate = validDate; // æ ‡è®°ä½¿ç”¨çš„æ—¥æœŸ
                                            indicator.dataDate = validDate; // åŒæ—¶æ›´æ–°æ•°æ®æ—¥æœŸ

                                            break;
                                        }
                                        validDateIndex--;
                                    }
                                }
                            }
                        }
                    }
                    
                    return indicators;
                } catch (error) {
                    return [];
                }
            }
        
        // è·å–æŒ‡æ ‡çš„å†å²æ•°æ®
        function getIndicatorHistory(allParsedRows, indicatorName) {
            return allParsedRows
                .filter(values => values.length > 4 && values[1] === indicatorName && values[4]) // ç¡®ä¿æ•°æ®å®Œæ•´ä¸”æŒ‡æ ‡åç§°åŒ¹é…
                .map(values => ({
                    date: values[0],
                    value: values[4]
                }))
                .sort((a, b) => new Date(a.date) - new Date(b.date));
        }
        
        // æ ¹æ®æŒ‡æ ‡åç§°è·å–å›ºå®šçš„åˆ¤æ–­æ ‡å‡†è¯´æ˜
        function getThresholdExplanationForIndicator(indicatorName) {
            // ä¸ºæ‰€æœ‰æŒ‡æ ‡æä¾›å›ºå®šçš„åˆ¤æ–­æ ‡å‡†
            if (indicatorName === 'CNN Fear & Greed') {
                return 'ä¹è§‚ (45-55): å¸‚åœºæƒ…ç»ªå¤„äºä¸­æ€§å¹³è¡¡ç‚¹ï¼ŒæŠ•èµ„è€…ç†æ€§ç¨‹åº¦è¾ƒé«˜ã€‚ä¸­æ€§ (25-44 æˆ– 56-75): å¸‚åœºè¿›å…¥"ææƒ§"æˆ–"è´ªå©ª"çŠ¶æ€ï¼Œæƒ…ç»ªåå‘æ˜æ˜¾ä½†æœªæç«¯åŒ–ã€‚æ‚²è§‚/è­¦ç¤º (â‰¤ 24 æˆ– â‰¥ 76): å¸‚åœºè¿›å…¥"æåº¦ææƒ§"æˆ–"æåº¦è´ªå©ª"çŠ¶æ€ï¼Œæƒ…ç»ªæç«¯åŒ–ã€‚';
            } else if (indicatorName === 'SPY å½“æ—¥å‡€æµå…¥é‡‘é¢') {
                return 'ä¹è§‚ (â‰¥ +5äº¿): å¤§é¢å‡€æµå…¥ã€‚ä¸­æ€§ (-5äº¿ ~ +5äº¿): èµ„é‡‘è¿›å‡ºå¹³è¡¡ã€‚æ‚²è§‚ (â‰¤ -5äº¿): å¤§é¢å‡€æµå‡ºã€‚';
            } else if (indicatorName === 'é¿é™©èµ„äº§æµå‘ (TLT+GLD)') {
                return 'ä¹è§‚ (< -10äº¿)ï¼šé¿é™©æµå‡ºã€‚ä¸­æ€§ (-10äº¿~+10äº¿)ï¼šå¹³è¡¡ã€‚æ‚²è§‚ (>+10äº¿)ï¼šé¿é™©æµå…¥ã€‚';
            } else if (indicatorName === 'VIX æŒ‡æ•° (ææ…ŒæŒ‡æ•°)') {
                return 'ä¹è§‚ (< 20): å¸‚åœºæ³¢åŠ¨æ€§ä½ï¼ŒæŠ•èµ„è€…æƒ…ç»ªå¹³ç¨³ã€‚ä¸­æ€§ (20-30): å¸‚åœºæ³¢åŠ¨æ€§ä¸­ç­‰ã€‚æ‚²è§‚ (> 30): å¸‚åœºææ…Œæƒ…ç»ªé«˜æ¶¨ï¼Œæ³¢åŠ¨æ€§å¤§ã€‚';
            } else if (indicatorName === 'Put/Call Ratio') {
                return 'ä¹è§‚ (< 0.7): çœ‹æ¶¨æœŸæƒäº¤æ˜“æ´»è·ƒã€‚ä¸­æ€§ (0.7-1.0): çœ‹æ¶¨çœ‹è·ŒæœŸæƒäº¤æ˜“å¹³è¡¡ã€‚æ‚²è§‚ (> 1.0): çœ‹è·ŒæœŸæƒäº¤æ˜“æ´»è·ƒï¼Œé¿é™©æƒ…ç»ªæµ“åšã€‚';
            } else if (indicatorName === 'TRIN æŒ‡æ•° (Arms Index)') {
                return 'ä¹è§‚ (< 0.8): å¸‚åœºä¹°ç›˜å¼ºåŠ²ã€‚ä¸­æ€§ (0.8-1.2): å¸‚åœºä¹°å–åŠ›é‡å¹³è¡¡ã€‚æ‚²è§‚ (> 1.2): å¸‚åœºå–ç›˜å¼ºåŠ²ã€‚';

            } else if (indicatorName === 'æ¶¨è·Œæ¯” (A/D Ratio)') {
                return 'ä¹è§‚ (> 1.5): ä¸Šæ¶¨è‚¡ç¥¨æ•°é‡æ˜æ˜¾å¤šäºä¸‹è·Œè‚¡ç¥¨ã€‚ä¸­æ€§ (0.8-1.5): ä¸Šæ¶¨ä¸‹è·Œè‚¡ç¥¨æ•°é‡ç›¸å¯¹å¹³è¡¡ã€‚æ‚²è§‚ (< 0.8): ä¸‹è·Œè‚¡ç¥¨æ•°é‡æ˜æ˜¾å¤šäºä¸Šæ¶¨è‚¡ç¥¨ã€‚';
            } else if (indicatorName === 'æ–°é«˜/æ–°ä½æ¯” (NH/NL)') {
                return 'ä¹è§‚ (> 10): åˆ›æ–°é«˜è‚¡ç¥¨è¿œå¤šäºåˆ›æ–°ä½è‚¡ç¥¨ã€‚ä¸­æ€§ (0.8-10): åˆ›æ–°é«˜æ–°ä½è‚¡ç¥¨ç›¸å¯¹å¹³è¡¡ã€‚æ‚²è§‚ (< 0.5): åˆ›æ–°ä½è‚¡ç¥¨è¿œå¤šäºåˆ›æ–°é«˜è‚¡ç¥¨ã€‚';
            } else if (indicatorName === 'æˆäº¤é‡è¶‹åŠ¿ (SPY)') {
                return 'ä¹è§‚ (> 1.2): æˆäº¤é‡æ˜æ˜¾æ”¾å¤§ã€‚ä¸­æ€§ (0.8-1.2): æˆäº¤é‡å˜åŒ–ä¸å¤§ã€‚æ‚²è§‚ (< 0.8): æˆäº¤é‡æ˜æ˜¾èç¼©ã€‚';
            } else if (indicatorName === 'ç¾å…ƒæŒ‡æ•° (DXY)') {
                return 'ä¹è§‚ (< 100): ç¾å…ƒèµ°å¼±ï¼Œæœ‰åˆ©äºé£é™©èµ„äº§ã€‚ä¸­æ€§ (100-103): ç¾å…ƒç›¸å¯¹ç¨³å®šã€‚æ‚²è§‚ (> 103): ç¾å…ƒèµ°å¼ºï¼Œä¸åˆ©é£é™©èµ„äº§ã€‚';
            } else if (indicatorName === 'æŒ‡æ•°ä¸å‡çº¿ (S&P 500)') {
                return 'ä¹è§‚ï¼šä»·æ ¼ > MA20 & MA50ã€‚ä¸­æ€§ï¼šä»·æ ¼å¾˜å¾Šäº MA20 é™„è¿‘ã€‚æ‚²è§‚ï¼šè·Œç ´ MA50ã€‚';
            }
            return ''; // é»˜è®¤è¿”å›ç©ºå­—ç¬¦ä¸²
        }
        
        // æ ¹æ®åˆ¤æ–­ç»“æœè·å–æƒ…ç»ªç±»å‹
        function getSentimentType(judgement) {
            if (!judgement || judgement.trim() === '') return 'missing';
            
            switch (judgement) {
                case 'ä¹è§‚': return 'optimistic';
                case 'ä¸­æ€§': return 'neutral';
                case 'æ‚²è§‚': return 'pessimistic';
                case 'æ‚²è§‚/è­¦ç¤º': return 'pessimistic'; // æ·»åŠ å¯¹æ‚²è§‚/è­¦ç¤ºçš„å¤„ç†
                default: return 'missing';
            }
        }
        
        // è·å–æƒ…ç»ªæ ‡ç­¾æ–‡æœ¬
        function getSentimentLabel(sentiment) {
            switch (sentiment) {
                case "optimistic": return "ä¹è§‚";
                case "neutral": return "ä¸­æ€§";
                case "pessimistic": return "æ‚²è§‚";
                case "missing": return "ç¼ºå¤±";
                default: return "æœªçŸ¥";
            }
        }
        
        // æ ¼å¼åŒ–æŒ‡æ ‡å€¼
        function formatValue(value, indicatorName) {
            if (!value || value === 'undefined' || value === 'null' || value === 'N/A' || value === 'n/a') return '';
            
            // ç‰¹æ®Šå¤„ç†æŒ‡æ•°ä¸å‡çº¿æŒ‡æ ‡ï¼Œåªæ˜¾ç¤ºç¬¬ä¸€ä¸ªæ•°å­—ï¼ˆå½“å‰ä»·æ ¼ï¼‰
            if (indicatorName.includes('æŒ‡æ•°ä¸å‡çº¿')) {
                const firstValue = value.split(' / ')[0] || value.split('/')[0] || value;
                return parseFloat(firstValue).toFixed(2);
            }
            
            // æ ¹æ®æŒ‡æ ‡ç±»å‹è¿›è¡Œæ ¼å¼åŒ–
            if (indicatorName.includes('Ratio') || indicatorName.includes('æ¯”')) {
                return parseFloat(value).toFixed(2);
            } else if (indicatorName.includes('æŒ‡æ•°')) {
                return parseFloat(value).toFixed(2);
            } else if (indicatorName.includes('æµå…¥') || indicatorName.includes('æµå‘')) {
                if (isNaN(parseFloat(value))) return value;
                const num = parseFloat(value);
                return num >= 1000 ? (num / 1000).toFixed(1) + 'B' : num.toFixed(1) + 'M';
            } else if (indicatorName === 'CNN Fear & Greed') {
                return parseFloat(value).toFixed(0);
            }
            
            return value;
        }

        // è®¡ç®—æƒ…ç»ªè¶‹åŠ¿
        function calculateTrend(data, sentimentType, recentDays = 5) {
            if (!data || data.length < 2) return { trend: 'neutral', change: 0, description: 'æ•°æ®ä¸è¶³' };
            
            // è·å–æœ€æ–°å€¼å’Œ5å¤©å‰çš„å€¼è¿›è¡Œæ¯”è¾ƒ
            const latestValue = data[data.length - 1][sentimentType];
            const compareIndex = Math.max(0, data.length - recentDays - 1);
            const compareValue = data[compareIndex][sentimentType];
            
            const change = latestValue - compareValue;
            const days = Math.min(recentDays, data.length - 1);
            
            let trend = 'neutral';
            let description = '';
            
            if (change > 0) {
                trend = 'up';
                description = `è¿‘${days}æ—¥ +${change}`;
            } else if (change < 0) {
                trend = 'down';
                description = `è¿‘${days}æ—¥ ${change}`;
            } else {
                trend = 'neutral';
                description = `è¿‘${days}æ—¥ æ— å˜åŒ–`;
            }
            
            return { trend, change, description };
        }

        // æ›´æ–°è¶‹åŠ¿æ˜¾ç¤º
        function updateTrendDisplay(elementId, trendData) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            let trendText = '';
            let trendClass = '';
            
            switch (trendData.trend) {
                case 'up':
                    trendText = `${trendData.description} â†‘`;
                    trendClass = 'trend-up';
                    break;
                case 'down':
                    trendText = `${trendData.description} â†“`;
                    trendClass = 'trend-down';
                    break;
                default:
                    trendText = `${trendData.description} â†’`;
                    trendClass = 'trend-neutral';
            }
            
            element.textContent = trendText;
            element.className = 'trend ' + trendClass;
        }

        // åˆ›å»ºæƒ…ç»ªåˆ†å¸ƒè¶‹åŠ¿å›¾
        function createSentimentChart(data) {
            console.log('createSentimentChartæ¥æ”¶åˆ°çš„æ•°æ®:', data);
            
            // æ£€æŸ¥canvaså…ƒç´ æ˜¯å¦å­˜åœ¨
            const canvasElement = document.getElementById('sentimentChart');
            if (!canvasElement) {
                console.error('æ‰¾ä¸åˆ°sentimentChart canvaså…ƒç´ !');
                return;
            }
            
            const ctx = canvasElement.getContext('2d');
            if (!ctx) {
                console.error('æ— æ³•è·å–canvas 2dä¸Šä¸‹æ–‡!');
                return;
            }
            
            // æ£€æŸ¥æ•°æ®æ˜¯å¦æœ‰æ•ˆ
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('ä¼ å…¥çš„æ•°æ®æ— æ•ˆ:', data);
                return;
            }
            
            // æå–æ—¥æœŸå’Œå„ç±»æƒ…ç»ªæ•°é‡
            const labels = data.map(item => formatDate(item.date));
            const optimisticData = data.map(item => item.optimistic);
            const neutralData = data.map(item => item.neutral);
            const pessimisticData = data.map(item => item.pessimistic);
            const missingData = data.map(item => item.missing);
            
            console.log('å›¾è¡¨æ•°æ®:', { labels, optimisticData, neutralData, pessimisticData, missingData });
            
            // æ£€æŸ¥Chart.jsæ˜¯å¦åŠ è½½
            if (typeof Chart === 'undefined') {
                console.error('Chart.jsåº“æœªåŠ è½½!');
                return;
            }
            
            // åˆ›å»ºå †å æŸ±çŠ¶å›¾
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'ä¹è§‚',
                            data: optimisticData,
                            backgroundColor: 'rgba(39, 174, 96, 0.7)',
                            borderColor: 'rgba(39, 174, 96, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'ä¸­æ€§',
                            data: neutralData,
                            backgroundColor: 'rgba(243, 156, 18, 0.7)',
                            borderColor: 'rgba(243, 156, 18, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'æ‚²è§‚',
                            data: pessimisticData,
                            backgroundColor: 'rgba(231, 76, 60, 0.7)',
                            borderColor: 'rgba(231, 76, 60, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'ç¼ºå¤±',
                            data: missingData,
                            backgroundColor: 'rgba(149, 165, 166, 0.7)',
                            borderColor: 'rgba(149, 165, 166, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        title: {
                            display: true,
                            text: 'ç¾è‚¡æƒ…ç»ªæŒ‡æ ‡åˆ†å¸ƒè¶‹åŠ¿'
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'æ—¥æœŸ'
                            }
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'æŒ‡æ ‡æ•°é‡'
                            },
                            min: 0
                        }
                    },
                    animation: {
                        duration: 1000
                    }
                }
            });
            
            console.log('æƒ…ç»ªåˆ†å¸ƒå›¾è¡¨åˆ›å»ºæˆåŠŸ!');
        }
        
        // åˆ›å»ºæµ‹è¯•å›¾è¡¨
        function createTestChart() {
            console.log('åˆ›å»ºæµ‹è¯•å›¾è¡¨...');
            
            const canvasElement = document.getElementById('sentimentChart');
            if (!canvasElement) {
                console.error('æ‰¾ä¸åˆ°sentimentChart canvaså…ƒç´ !');
                return;
            }
            
            const ctx = canvasElement.getContext('2d');
            
            // æµ‹è¯•æ•°æ®
            const testData = {
                labels: ['2025-06-20', '2025-06-21', '2025-06-22', '2025-06-23'],
                datasets: [{
                    label: 'ä¹è§‚',
                    data: [3, 4, 2, 5],
                    backgroundColor: '#27ae60',
                    stack: 'stack1'
                }, {
                    label: 'ä¸­æ€§',
                    data: [2, 3, 4, 2],
                    backgroundColor: '#f39c12',
                    stack: 'stack1'
                }, {
                    label: 'æ‚²è§‚',
                    data: [1, 2, 3, 1],
                    backgroundColor: '#e74c3c',
                    stack: 'stack1'
                }]
            };
            
            try {
                const chart = new Chart(ctx, {
                    type: 'bar',
                    data: testData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'æµ‹è¯•å›¾è¡¨ - æƒ…ç»ªåˆ†å¸ƒ'
                            },
                            legend: {
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'æ—¥æœŸ'
                                }
                            },
                            y: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'æŒ‡æ ‡æ•°é‡'
                                }
                            }
                        }
                    }
                });
                console.log('æµ‹è¯•å›¾è¡¨åˆ›å»ºæˆåŠŸ!', chart);
            } catch (error) {
                console.error('åˆ›å»ºæµ‹è¯•å›¾è¡¨å¤±è´¥:', error);
            }
        }

        // åˆ›å»ºå°æŠ˜çº¿å›¾
        function createMiniChart(canvasId, data, type, color) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`æ‰¾ä¸åˆ°canvaså…ƒç´ : ${canvasId}`);
                return;
            }
            
            // è·å–æœ€è¿‘5å¤©çš„æ•°æ®
            const recentData = data.slice(-5);
            const labels = recentData.map(item => {
                const date = new Date(item.date);
                return `${date.getMonth() + 1}/${date.getDate()}`;
            });
            const values = recentData.map(item => item[type] || 0);
            
            const ctx = canvas.getContext('2d');
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointBackgroundColor: color,
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    return tooltipItems[0].label;
                                },
                                label: function(tooltipItem) {
                                    return `${type}: ${tooltipItem.formattedValue}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false,
                            beginAtZero: true
                        }
                    },
                    elements: {
                        point: {
                            hoverRadius: 4
                        }
                    },
                    animation: {
                        duration: 800,
                        easing: 'easeInOutQuart'
                    }
                }
            });
        }

        // ç»Ÿä¸€çš„è¿·ä½ å›¾ç»˜åˆ¶å‡½æ•° (ä½¿ç”¨Chart.jså’ŒAnnotationsæ’ä»¶)
        function getThresholdsForIndicator(indicatorName) {
            if (indicatorName === 'VIX æŒ‡æ•° (ææ…ŒæŒ‡æ•°)') {
                return {
                    'optimistic': [0, 20],
                    'neutral': [20, 30],
                    'pessimistic': [30, 100]
                };
            } else if (indicatorName === 'TRIN æŒ‡æ•° (Arms Index)') {
                return {
                    'optimistic': [0, 0.8],
                    'neutral': [0.8, 1.2],
                    'pessimistic': [1.2, 3.0]
                };
            } else if (indicatorName === 'CNN Fear & Greed') {
                return {
                    'optimistic': [45, 55],
                    'neutral': [25, 75],
                    'pessimistic': [0, 100]
                };
            } else if (indicatorName === 'æ¶¨è·Œæ¯” (A/D Ratio)') {
                return {
                    'optimistic': [1.5, 10],
                    'neutral': [0.8, 1.5],
                    'pessimistic': [0, 0.8]
                };
            } else if (indicatorName === 'æ–°é«˜/æ–°ä½æ¯” (NH/NL)') {
                return {
                    'optimistic': [10, 100],
                    'neutral': [0.8, 10],
                    'pessimistic': [0, 0.5]
                };
            } else if (indicatorName === 'æˆäº¤é‡è¶‹åŠ¿ (SPY)') {
                return {
                    'optimistic': [1.2, 3],
                    'neutral': [0.8, 1.2],
                    'pessimistic': [0, 0.8]
                };
            } else if (indicatorName === 'SPY å½“æ—¥å‡€æµå…¥é‡‘é¢') {
                return {
                    'optimistic': [500, 10000],
                    'neutral': [-500, 500],
                    'pessimistic': [-10000, -500]
                };
            } else if (indicatorName === 'é¿é™©èµ„äº§æµå‘ (TLT+GLD)') {
                return {
                    'optimistic': [-10000, -1000],
                    'neutral': [-1000, 1000],
                    'pessimistic': [1000, 10000]
                };
            } else if (indicatorName === 'ç¾å…ƒæŒ‡æ•° (DXY)') {
                return {
                    'optimistic': [0, 100],
                    'neutral': [100, 103],
                    'pessimistic': [103, 200]
                };
            }
            
            // é»˜è®¤é˜ˆå€¼
            return {
                'optimistic': [0, 0.33],
                'neutral': [0.33, 0.66],
                'pessimistic': [0.66, 1]
            };
        }

        function drawMiniChart(canvasElement, indicatorData) {
            const ctx = canvasElement;
            const data = indicatorData.data || [];
            const indicatorName = indicatorData.name;
            
            // ç‰¹æ®Šå¤„ç†S&P 500æŒ‡æ•°
            if (indicatorName === 'æŒ‡æ•°ä¸å‡çº¿ (S&P 500)') {
                drawSP500Chart(ctx, data, indicatorData);
                return;
            }
            
            // è¿‡æ»¤æ‰ç¼ºå¤±æ•°æ®çš„æ•°æ®ç‚¹ï¼Œåªä¿ç•™æœ‰æ•ˆæ•°æ®
            const validData = data.filter(d => {
                const value = d.rawValue || d.value;
                return value && value !== 'N/A' && value !== 'n/a' && value.trim() !== '' && !isNaN(parseFloat(value));
            });
            
            // æå–æ—¥æœŸå’Œæ•°å€¼ï¼ˆåªåŒ…å«æœ‰æ•ˆæ•°æ®ï¼‰
            const dates = validData.map(d => formatDate(d.date));
            const values = validData.map(d => parseFloat(d.rawValue || d.value));
            
            // é”€æ¯æ—§çš„Chart.jså®ä¾‹ä»¥é˜²æ­¢é‡å¤ç»˜åˆ¶
            if (ctx.chart) {
                ctx.chart.destroy();
            }
            
            // è®¡ç®—æ•°æ®èŒƒå›´ï¼Œä¸ºäº†æ›´å¥½çš„è§†è§‰æ•ˆæœï¼Œæ‰©å±•Yè½´èŒƒå›´
            const minY = Math.min(...values.filter(v => !isNaN(v)));
            const maxY = Math.max(...values.filter(v => !isNaN(v)));
            const yRange = maxY - minY;
            
            // æ ¹æ®æŒ‡æ ‡ç±»å‹è®¾ç½®é€‚å½“çš„Yè½´èŒƒå›´
            let paddedMinY, paddedMaxY;
            
            // ç‰¹æ®Šå¤„ç†æŸäº›æŒ‡æ ‡çš„Yè½´èŒƒå›´
            if (indicatorName === 'VIX æŒ‡æ•° (ææ…ŒæŒ‡æ•°)') {
                // VIXæŒ‡æ•°é€šå¸¸åœ¨10-40ä¹‹é—´ï¼Œä½†å¯èƒ½ä¼šæ›´é«˜
                paddedMinY = Math.max(0, Math.min(10, minY - 5));
                paddedMaxY = Math.max(40, maxY + 5);
            } else if (indicatorName === 'CNN Fear & Greed') {
                // CNN Fear & Greedå›ºå®šä¸º0-100
                paddedMinY = 0;
                paddedMaxY = 100;
            } else if (indicatorName === 'TRIN æŒ‡æ•° (Arms Index)') {
                // TRINæŒ‡æ•°é€šå¸¸åœ¨0.5-2.0ä¹‹é—´ï¼Œä½†å¯èƒ½ä¼šæ›´é«˜
                paddedMinY = Math.max(0, Math.min(0.5, minY - 0.2));
                paddedMaxY = Math.max(2.0, maxY + 0.2);
            } else if (indicatorName === 'Put/Call Ratio') {
                // Put/Call Ratioé€šå¸¸åœ¨0.5-1.5ä¹‹é—´
                paddedMinY = Math.max(0, Math.min(0.5, minY - 0.1));
                paddedMaxY = Math.max(1.5, maxY + 0.1);
            } else if (indicatorName.includes('Ratio') || indicatorName.includes('æ¯”')) {
                // å…¶ä»–æ¯”ç‡ç±»æŒ‡æ ‡é€šå¸¸ä»0å¼€å§‹
                paddedMinY = Math.max(0, minY - yRange * 0.1);
                paddedMaxY = maxY + yRange * 0.1;
            } else if (indicatorName.includes('æµå…¥') || indicatorName.includes('æµå‘')) {
                // æµå…¥/æµå‘å¯èƒ½æœ‰æ­£è´Ÿå€¼
                const absMax = Math.max(Math.abs(minY), Math.abs(maxY));
                paddedMinY = -absMax * 1.1;
                paddedMaxY = absMax * 1.1;
            } else if (indicatorName.includes('æŒ‡æ•°') || indicatorName.includes('S&P') || indicatorName.includes('çº³æ–¯è¾¾å…‹')) {
                // æŒ‡æ•°ç±»é€šå¸¸éœ€è¦æ›´ç´§å‡‘çš„Yè½´èŒƒå›´ä»¥æ˜¾ç¤ºå˜åŒ–
                paddedMinY = minY - yRange * 0.05;
                paddedMaxY = maxY + yRange * 0.05;
            } else {
                // é»˜è®¤å¤„ç†
                paddedMinY = Math.max(0, minY - yRange * 0.1);
                paddedMaxY = maxY + yRange * 0.1;
            }
            

            
            // è·å–æŒ‡æ ‡çš„é˜ˆå€¼åŒºé—´
            const thresholds = getThresholdsForIndicator(indicatorName);
            
            // åˆ›å»ºæ³¨é‡Šé…ç½®
            let annotations = {};
            
            // é»˜è®¤å¤„ç†å…¶ä»–æŒ‡æ ‡
            if (false) {
                // ç§»é™¤äº†S&P 500çš„ç‰¹æ®Šå¤„ç†
                annotations['optimisticZone'] = {
                    type: 'box',
                    yMin: paddedMinY,
                    yMax: 0.7,
                    backgroundColor: 'rgba(39, 174, 96, 0.2)', // ä¹è§‚åŒºåŸŸï¼šç»¿è‰²
                    borderWidth: 0,
                    borderColor: 'transparent',
                    xMin: 0,
                    xMax: dates.length - 1,
                    z: -1
                };
                
                annotations['neutralZone'] = {
                    type: 'box',
                    yMin: 0.7,
                    yMax: 1.0,
                    backgroundColor: 'rgba(243, 156, 18, 0.2)', // ä¸­æ€§åŒºåŸŸï¼šé»„è‰²
                    borderWidth: 0,
                    borderColor: 'transparent',
                    xMin: 0,
                    xMax: dates.length - 1,
                    z: -1
                };
                
                annotations['pessimisticZone'] = {
                    type: 'box',
                    yMin: 1.0,
                    yMax: paddedMaxY,
                    backgroundColor: 'rgba(231, 76, 60, 0.2)', // æ‚²è§‚åŒºåŸŸï¼šçº¢è‰²
                    borderWidth: 0,
                    borderColor: 'transparent',
                    xMin: 0,
                    xMax: dates.length - 1,
                    z: -1
                };
            } else {
                // å…¶ä»–æŒ‡æ ‡æŒ‰åŸæ¥çš„é˜ˆå€¼åˆ›å»ºèƒŒæ™¯è‰²å—æ³¨é‡Š
                let annotationIndex = 0;
                for (const sentiment in thresholds) {
                    const [lower, upper] = thresholds[sentiment];
                    let backgroundColor;
                    
                    if (sentiment.includes('optimistic') || sentiment === 'optimistic') {
                        backgroundColor = 'rgba(39, 174, 96, 0.3)'; // ä¹è§‚è‰²
                    } else if (sentiment.includes('neutral') || sentiment === 'neutral') {
                        backgroundColor = 'rgba(243, 156, 18, 0.3)'; // ä¸­æ€§è‰²
                    } else if (sentiment.includes('pessimistic') || sentiment === 'pessimistic') {
                        backgroundColor = 'rgba(231, 76, 60, 0.3)'; // æ‚²è§‚è‰²
                    }
                    
                    annotations[`box${annotationIndex}`] = {
                        type: 'box',
                        yMin: lower !== null ? lower : paddedMinY,
                        yMax: upper !== null ? upper : paddedMaxY,
                        backgroundColor: backgroundColor,
                        borderWidth: 0,
                        borderColor: 'transparent',
                        xMin: 0,
                        xMax: dates.length - 1,
                        z: -1 // ç¡®ä¿èƒŒæ™¯è‰²å—åœ¨æŠ˜çº¿å›¾ä¸‹æ–¹
                    };
                    annotationIndex++;
                }
            }
            
            // åˆ›å»ºChart.jsé…ç½®
            const chartConfig = {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        data: values,
                        borderColor: '#2c3e50',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 4,
                        pointBackgroundColor: '#2c3e50',
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        pointHoverRadius: 6,
                        pointHoverBackgroundColor: '#e74c3c',
                        pointHoverBorderColor: 'white',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: { display: false },
                        title: { display: false },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    return tooltipItems[0].label;
                                },
                                label: function(tooltipItem) {
                                    const dataPoint = data[tooltipItem.dataIndex];
                                    let label = `${tooltipItem.formattedValue}`;
                                    
                                    // å¦‚æœæœ‰æƒ…ç»ªç±»å‹ï¼Œæ˜¾ç¤ºæƒ…ç»ªç±»å‹
                                    if (dataPoint && dataPoint.sentiment) {
                                        label += ` [${getSentimentLabel(dataPoint.sentiment)}]`;
                                    }
                                    
                                    return label;
                                }
                            }
                        },
                        annotation: {
                            annotations: annotations
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: { 
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)',
                                lineWidth: 1
                            },
                            ticks: {
                                maxRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 5,
                                font: {
                                    size: 10
                                },
                                color: '#666'
                            }
                        },
                        y: {
                            display: true,
                            grid: { 
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)',
                                lineWidth: 1
                            },
                            suggestedMin: paddedMinY,
                            suggestedMax: paddedMaxY,
                            ticks: {
                                font: {
                                    size: 10
                                },
                                color: '#666'
                            }
                        }
                    },
                    elements: {
                        point: { radius: 2 }
                    },
                    animation: {
                        duration: 1000
                    }
                }
            };
            
            // ç‰¹æ®Šå¤„ç†CNN Fear & GreedæŒ‡æ ‡
            if (indicatorName === 'CNN Fear & Greed') {
                // æ¸…ç©ºä¹‹å‰çš„æ³¨é‡Šé…ç½®
                annotations = {};
                
                // CNN Fear & Greedçš„é˜ˆå€¼ - æ ¹æ®ç”¨æˆ·æä¾›çš„æ­£ç¡®åŒºé—´
                // ä¹è§‚ï¼ˆ45-55ï¼‰ï¼Œä¸­æ€§ï¼ˆ25-44å’Œ56-75ï¼‰ï¼Œæ‚²è§‚/è­¦ç¤ºï¼ˆâ‰¤24æˆ–â‰¥76ï¼‰
                const cnn_thresholds = {
                    'æ‚²è§‚/è­¦ç¤º (â‰¤24)': [0, 24, 'rgba(231, 76, 60, 0.3)'],
                    'ä¸­æ€§ (25-44)': [25, 44, 'rgba(243, 156, 18, 0.3)'],
                    'ä¹è§‚ (45-55)': [45, 55, 'rgba(39, 174, 96, 0.3)'],
                    'ä¸­æ€§ (56-75)': [56, 75, 'rgba(243, 156, 18, 0.3)'],
                    'æ‚²è§‚/è­¦ç¤º (â‰¥76)': [76, 100, 'rgba(231, 76, 60, 0.3)']
                };
                
                // åˆ›å»ºCNN Fear & Greedçš„èƒŒæ™¯è‰²å—æ³¨é‡Š
                annotationIndex = 0;
                for (const sentiment in cnn_thresholds) {
                    const [lower, upper, color] = cnn_thresholds[sentiment];
                    annotations[`box${annotationIndex}`] = {
                        type: 'box',
                        yMin: lower,
                        yMax: upper,
                        backgroundColor: color,
                        borderWidth: 0,
                        borderColor: 'transparent',
                        xMin: 0,
                        xMax: dates.length - 1,
                        z: -1 // ç¡®ä¿èƒŒæ™¯è‰²å—åœ¨æŠ˜çº¿å›¾ä¸‹æ–¹
                    };
                    annotationIndex++;
                }
                
                // æ›´æ–°æ³¨é‡Šé…ç½®
                chartConfig.options.plugins.annotation.annotations = annotations;
                
                // è®¾ç½®å›ºå®šçš„Yè½´èŒƒå›´
                chartConfig.options.scales.y.min = 0;
                chartConfig.options.scales.y.max = 100;
            }
            

            
            // åˆ›å»ºChart.jså®ä¾‹
            ctx.chart = new Chart(ctx, chartConfig);
            
            return ctx.chart;
        }
        
        // ä¿ç•™åŸå§‹å‡½æ•°ä½œä¸ºå¤‡ä»½
        function drawLineChartWithZones(canvasElement, data, thresholds, colors, options = {}) {
            // ä½¿ç”¨æ–°çš„drawMiniChartå‡½æ•°æ›¿ä»£
            const indicatorData = {
                name: 'æŒ‡æ ‡',
                data: data
            };
            return drawMiniChart(canvasElement, indicatorData);
        }

        // æŒ‡æ ‡åˆ†ç±»å®šä¹‰
        const indicatorCategories = {
            'å¸‚åœºå¹¿åº¦æŒ‡æ ‡': {
                title: 'å¸‚åœºå¹¿åº¦æŒ‡æ ‡ (ä¸Šæ¶¨æ˜¯å¦"å¥åº·")',
                indicators: ['æ¶¨è·Œæ¯” (A/D Ratio)', 'æ–°é«˜/æ–°ä½æ¯” (NH/NL Ratio)', 'TRIN æŒ‡æ•° (Arms Index)']
            },
            'æƒ…ç»ªé‡åŒ–æŒ‡æ ‡': {
                title: 'æƒ…ç»ªé‡åŒ–æŒ‡æ ‡ (æƒ…ç»ªæ˜¯å¦"ææ…Œ"æˆ–"è´ªå©ª")',
                indicators: ['VIX æŒ‡æ•°', 'Put/Call Ratio', 'CNN Fear & Greed Index', 'VIX æŒ‡æ•° (ææ…ŒæŒ‡æ•°)', 'CNN Fear & Greed']
            },
            'èµ„é‡‘æµå‘ä¸åŠ¨èƒ½æŒ‡æ ‡': {
                title: 'èµ„é‡‘æµå‘ä¸åŠ¨èƒ½æŒ‡æ ‡ (èµ„é‡‘çš„åŠ¨å‘ä¸äº¤æ˜“æ´»è·ƒåº¦)',
                indicators: ['æˆäº¤é‡è¶‹åŠ¿ (SPY)', 'SPY å½“æ—¥å‡€æµå…¥é‡‘é¢', 'é¿é™©èµ„äº§æµå‘ (TLT+GLD)']
            },
            'å…¶å®ƒ': {
                title: 'å…¶å®ƒæŒ‡æ ‡',
                indicators: []
            }
        };

        // æ ¹æ®æŒ‡æ ‡åç§°è·å–åˆ†ç±»
        function getIndicatorCategory(indicatorName) {
            for (const [category, config] of Object.entries(indicatorCategories)) {
                if (category === 'å…¶å®ƒ') continue;
                if (config.indicators.some(name => indicatorName.includes(name.split(' ')[0]) || name.includes(indicatorName.split(' ')[0]))) {
                    return category;
                }
            }
            return 'å…¶å®ƒ';
        }

        // æ¸²æŸ“æŒ‡æ ‡å¡ç‰‡
        function renderIndicatorCards(indicators) {
            const gridContainer = document.getElementById('indicatorsGrid');
            gridContainer.innerHTML = '';
            
            // æŒ‰åˆ†ç±»ç»„ç»‡æŒ‡æ ‡
            const categorizedIndicators = {};
            indicators.forEach(indicator => {
                const category = getIndicatorCategory(indicator.name);
                if (!categorizedIndicators[category]) {
                    categorizedIndicators[category] = [];
                }
                categorizedIndicators[category].push(indicator);
            });
            
            // æŒ‰é¢„å®šä¹‰é¡ºåºæ¸²æŸ“å„åˆ†ç±»
            const categoryOrder = ['å¸‚åœºå¹¿åº¦æŒ‡æ ‡', 'æƒ…ç»ªé‡åŒ–æŒ‡æ ‡', 'èµ„é‡‘æµå‘ä¸åŠ¨èƒ½æŒ‡æ ‡', 'å…¶å®ƒ'];
            
            categoryOrder.forEach(categoryKey => {
                const categoryIndicators = categorizedIndicators[categoryKey];
                if (!categoryIndicators || categoryIndicators.length === 0) return;
                
                // åˆ›å»ºåˆ†ç±»æ ‡é¢˜
                const categoryTitle = document.createElement('div');
                categoryTitle.className = 'category-title';
                categoryTitle.innerHTML = `<h2>${indicatorCategories[categoryKey].title}</h2>`;
                gridContainer.appendChild(categoryTitle);
                
                // åˆ›å»ºè¯¥åˆ†ç±»çš„æŒ‡æ ‡å®¹å™¨
                const categoryContainer = document.createElement('div');
                categoryContainer.className = 'category-indicators';
                
                categoryIndicators.forEach((indicator, index) => {
                const card = document.createElement('div');
                card.className = `indicator-card ${indicator.sentiment}`;
                
                // å¡ç‰‡å¤´éƒ¨ï¼ˆæŒ‡æ ‡åç§°å’Œæƒ…ç»ªæ ‡ç­¾ï¼‰
                const header = document.createElement('div');
                header.className = 'indicator-header';
                
                const name = document.createElement('div');
                name.className = 'indicator-name';
                
                // ä¸ºSPYå½“æ—¥å‡€æµå…¥é‡‘é¢å’Œé¿é™©èµ„äº§æµå‘æ·»åŠ æ—¥æœŸæ ‡æ³¨
                if (indicator.name === 'SPY å½“æ—¥å‡€æµå…¥é‡‘é¢' || indicator.name === 'é¿é™©èµ„äº§æµå‘ (TLT+GLD)') {
                    // æ˜¾ç¤ºå®é™…æ•°æ®çš„æ—¥æœŸ
                    const actualDataDate = indicator.previousDataDate || indicator.dataDate;
                    name.innerHTML = `${indicator.name}<br><span style="font-size: 0.8em; color: #777;">(${actualDataDate})</span>`;
                } else {
                    name.textContent = indicator.name;
                }
                
                const sentiment = document.createElement('div');
                sentiment.className = `indicator-sentiment sentiment-${indicator.sentiment}`;
                sentiment.textContent = getSentimentLabel(indicator.sentiment);
                
                header.appendChild(name);
                header.appendChild(sentiment);
                
                // æŒ‡æ ‡æ•°å€¼
                const value = document.createElement('div');
                value.className = 'indicator-value';
                const formattedValue = formatValue(indicator.value, indicator.name);
                
                // å¦‚æœå€¼ä¸ºç©ºï¼Œæ˜¾ç¤ºæ•°æ®ç¼ºå¤±
                if (formattedValue === '') {
                    value.textContent = 'æ•°æ®ç¼ºå¤±';
                    value.classList.add('value-na');
                } else {
                    value.textContent = formattedValue;
                }
                
                // ç»„è£…å¡ç‰‡åŸºæœ¬å…ƒç´ 
                card.appendChild(header);
                card.appendChild(value);
                

                
                // æ·»åŠ æ¯æ—¥æœ€æ–°æŒ‡æ ‡è§£è¯»ï¼ˆå›¾è¡¨ä¸Šæ–¹ï¼‰
                if (indicator.detailedExplanation) {
                    const detailedTitle = document.createElement('div');
                    detailedTitle.style.cssText = 'font-weight: bold; color: #2c3e50; margin: 10px 0 5px 0; font-size: 0.85em;';
                    detailedTitle.textContent = 'ğŸ“Š æ¯æ—¥æœ€æ–°æŒ‡æ ‡è§£è¯»';
                    card.appendChild(detailedTitle);
                    
                    const detailedExplanation = document.createElement('div');
                    detailedExplanation.className = 'detailed-explanation';
                    detailedExplanation.style.fontSize = '1.05em';
                    detailedExplanation.innerHTML = indicator.detailedExplanation;
                    card.appendChild(detailedExplanation);
                }
                
                // è¿·ä½ å›¾è¡¨ï¼ˆæ˜¾ç¤ºå†å²æ•°æ®ï¼‰
                const miniChart = document.createElement('div');
                miniChart.className = 'mini-chart';
                
                // åªæœ‰å½“æŒ‡æ ‡æœ‰å†å²æ•°æ®æ—¶æ‰æ˜¾ç¤ºå›¾è¡¨
                if (indicator.data && indicator.data.length > 0) {
                    // åˆ›å»ºCanvaså…ƒç´ ç”¨äºç»˜åˆ¶å›¾è¡¨
                    const canvas = document.createElement('canvas');
                    canvas.width = 300;
                    canvas.height = 100;
                    miniChart.appendChild(canvas);
                    
                    // ä½¿ç”¨drawMiniChartå‡½æ•°ç»˜åˆ¶å†å²æ•°æ®å›¾è¡¨
                    setTimeout(() => {
                        drawMiniChart(canvas, indicator);
                    }, 0);
                } else {
                    miniChart.style.display = 'none'; // å¦‚æœæ²¡æœ‰å†å²æ•°æ®åˆ™éšè—
                }
                
                card.appendChild(miniChart);
                
                // æ·»åŠ åˆ¤æ–­æ ‡å‡†ï¼ˆå›¾è¡¨ä¸‹æ–¹ï¼‰
                if (indicator.thresholdExplanation) {
                    const thresholdTitle = document.createElement('div');
                    thresholdTitle.style.cssText = 'font-weight: bold; color: #2c3e50; margin: 10px 0 5px 0; font-size: 0.85em;';
                    thresholdTitle.textContent = 'ğŸ“‹ åˆ¤æ–­æ ‡å‡†';
                    card.appendChild(thresholdTitle);
                    
                    const thresholdExplanation = document.createElement('div');
                    thresholdExplanation.className = 'threshold-explanation';
                    thresholdExplanation.innerHTML = indicator.thresholdExplanation;
                    card.appendChild(thresholdExplanation);
                }
                
                categoryContainer.appendChild(card);
                });
                
                gridContainer.appendChild(categoryContainer);
            });
        }
        


        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // ä»CSVæ–‡ä»¶åŠ è½½æ•°æ®
                const response = await fetch('enhanced_processed_sentiment_data.csv');
                const csvText = await response.text();
                const lines = csvText.split('\n').filter(line => line.trim() !== '');
                console.log('CSVæ€»è¡Œæ•°:', lines.length);
                console.log('CSVå¤´éƒ¨:', lines[0]);
                
                const parsedRows = lines.slice(1).map(line => parseCsvLine(line));
                console.log('è§£æåçš„å‰3è¡Œæ•°æ®:', parsedRows.slice(0, 3));
                
                // æ£€æŸ¥æ•°æ®ç»“æ„
                if (parsedRows.length > 0) {
                    console.log('ç¬¬ä¸€è¡Œæ•°æ®ç»“æ„:', {
                        'åˆ—0(æ—¥æœŸ)': parsedRows[0][0],
                        'åˆ—1(æŒ‡æ ‡åç§°)': parsedRows[0][1], 
                        'åˆ—2(åˆ¤æ–­ç»“æœ)': parsedRows[0][2],
                        'åˆ—3(æƒ…ç»ªå¾—åˆ†)': parsedRows[0][3],
                        'åˆ—4(æ•°å€¼æ•°æ®)': parsedRows[0][4]
                    });
                }
                
                // ç”Ÿæˆæƒ…ç»ªåˆ†å¸ƒæ•°æ®
                const sentimentData = generateSentimentDistribution(parsedRows);
                console.log('ç”Ÿæˆçš„æƒ…ç»ªåˆ†å¸ƒæ•°æ®:', sentimentData);
                
                if (sentimentData && sentimentData.overall_sentiment_distribution.length > 0) {
                    // æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
                    const lastDate = sentimentData.overall_sentiment_distribution[sentimentData.overall_sentiment_distribution.length - 1].date;
                    document.getElementById('lastUpdate').textContent = `æœ€åæ›´æ–°: ${lastDate}`;
                    
                    // åˆ›å»ºæƒ…ç»ªåˆ†å¸ƒè¶‹åŠ¿å›¾
                    createSentimentChart(sentimentData.overall_sentiment_distribution);
                    
                    // æ›´æ–°æƒ…ç»ªç»Ÿè®¡å¡ç‰‡
                    const latestData = sentimentData.overall_sentiment_distribution[sentimentData.overall_sentiment_distribution.length - 1];
                    document.getElementById('optimisticValue').textContent = latestData.optimistic;
                    document.getElementById('neutralValue').textContent = latestData.neutral;
                    document.getElementById('pessimisticValue').textContent = latestData.pessimistic;
                    
                    // è®¡ç®—å¹¶æ˜¾ç¤ºè¶‹åŠ¿
                    const optimisticTrend = calculateTrend(sentimentData.overall_sentiment_distribution, 'optimistic');
                    const neutralTrend = calculateTrend(sentimentData.overall_sentiment_distribution, 'neutral');
                    const pessimisticTrend = calculateTrend(sentimentData.overall_sentiment_distribution, 'pessimistic');
                    
                    updateTrendDisplay('optimisticTrend', optimisticTrend);
                    updateTrendDisplay('neutralTrend', neutralTrend);
                    updateTrendDisplay('pessimisticTrend', pessimisticTrend);
                    
                    // åˆ›å»ºå°æŠ˜çº¿å›¾
                    createMiniChart('optimisticChart', sentimentData.overall_sentiment_distribution, 'optimistic', '#27ae60');
                    createMiniChart('neutralChart', sentimentData.overall_sentiment_distribution, 'neutral', '#f39c12');
                    createMiniChart('pessimisticChart', sentimentData.overall_sentiment_distribution, 'pessimistic', '#e74c3c');
                } else {
                    console.warn('æƒ…ç»ªæ•°æ®ä¸ºç©ºæˆ–æ— æ•ˆï¼Œåˆ›å»ºæµ‹è¯•å›¾è¡¨');
                    // åˆ›å»ºæµ‹è¯•å›¾è¡¨
                    createTestChart();
                    
                    // æ›´æ–°æƒ…ç»ªç»Ÿè®¡å¡ç‰‡
                    const latestData = sentimentData.overall_sentiment_distribution[sentimentData.overall_sentiment_distribution.length - 1];
                    document.getElementById('optimisticValue').textContent = latestData.optimistic;
                    document.getElementById('neutralValue').textContent = latestData.neutral;
                    document.getElementById('pessimisticValue').textContent = latestData.pessimistic;
                    
                    // è®¡ç®—å¹¶æ˜¾ç¤ºè¶‹åŠ¿
                    const optimisticTrend = calculateTrend(sentimentData.overall_sentiment_distribution, 'optimistic');
                    const neutralTrend = calculateTrend(sentimentData.overall_sentiment_distribution, 'neutral');
                    const pessimisticTrend = calculateTrend(sentimentData.overall_sentiment_distribution, 'pessimistic');
                    
                    updateTrendDisplay('optimisticTrend', optimisticTrend);
                    updateTrendDisplay('neutralTrend', neutralTrend);
                    updateTrendDisplay('pessimisticTrend', pessimisticTrend);
                }
                
                // åŠ è½½æŒ‡æ ‡è¯¦æƒ…æ•°æ®
                const indicators = await loadIndicatorsData();
                
                if (indicators && indicators.length > 0) {
                    renderIndicatorCards(indicators);
                } else {
                    const gridContainer = document.getElementById('indicatorsGrid');
                    if (gridContainer) {
                        gridContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">æš‚æ— æŒ‡æ ‡æ•°æ®</p>';
                    }
                }
            } catch (error) {
                console.error('åŠ è½½æ•°æ®æ—¶å‡ºé”™:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ç»™ç”¨æˆ·
                 const errorDiv = document.createElement('div');
                 errorDiv.style.cssText = 'background: #ffebee; color: #c62828; padding: 15px; margin: 20px; border-radius: 5px; border: 1px solid #ef5350;';
                 errorDiv.innerHTML = `<strong>æ•°æ®åŠ è½½å¤±è´¥:</strong> ${error.message}`;
                 document.body.insertBefore(errorDiv, document.body.firstChild);
                 
                 const gridContainer = document.getElementById('indicatorsGrid');
                if (gridContainer) {
                    gridContainer.innerHTML = '<p style="text-align: center; color: #f44336; padding: 20px;">æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„</p>';
                }
            }
        });
        
        // ä¸“é—¨å¤„ç†S&P 500æŒ‡æ•°çš„å›¾è¡¨ç»˜åˆ¶å‡½æ•°
        function drawSP500Chart(ctx, data, indicatorData) {
            // é”€æ¯æ—§çš„Chart.jså®ä¾‹ä»¥é˜²æ­¢é‡å¤ç»˜åˆ¶
            if (ctx.chart) {
                ctx.chart.destroy();
            }
            
            // è¿‡æ»¤æ‰ç¼ºå¤±æ•°æ®çš„æ•°æ®ç‚¹ï¼Œåªä¿ç•™æœ‰æ•ˆæ•°æ®
            const validData = data.filter(d => {
                const value = d.rawValue || d.value;
                return value && value !== 'N/A' && value !== 'n/a' && value.trim() !== '';
            });
            
            if (validData.length === 0) {
                return;
            }
            
            // è§£æS&P 500æ•°æ®ï¼šæ ¼å¼ä¸º "ä»·æ ¼ / MA20 / MA50"
            const dates = validData.map(d => formatDate(d.date));
            const sp500Values = [];
            const ma20Values = [];
            const ma50Values = [];
            const sentiments = validData.map(d => d.sentiment);
            
            validData.forEach(d => {
                const value = d.rawValue || d.value;
                const parts = value.split('/');
                if (parts.length >= 3) {
                    // æ–œæ åˆ†éš”æ ¼å¼ï¼šä»·æ ¼/MA20/MA50
                    sp500Values.push(parseFloat(parts[0].trim()));
                    ma20Values.push(parseFloat(parts[1].trim()));
                    ma50Values.push(parseFloat(parts[2].trim()));
                } else {
                    // å°è¯•è§£æé€—å·åˆ†éš”çš„æ ¼å¼
                    const commaParts = value.split(',');
                    if (commaParts.length >= 3) {
                        // é€—å·åˆ†éš”æ ¼å¼ï¼šä»·æ ¼,MA20,MA50
                        sp500Values.push(parseFloat(commaParts[0].trim()));
                        ma20Values.push(parseFloat(commaParts[1].trim()));
                        ma50Values.push(parseFloat(commaParts[2].trim()));
                    } else {
                        // å•ä¸€æ•°å€¼æ ¼å¼ï¼šåªæœ‰ä»·æ ¼ï¼Œéœ€è¦ä»è§£é‡Šä¸­æå–MA20å’ŒMA50
                        const price = parseFloat(value.trim());
                        if (!isNaN(price)) {
                            sp500Values.push(price);
                            
                            // ä»è§£é‡Šæ–‡æœ¬ä¸­æå–MA20å’ŒMA50æ•°å€¼
                            const explanation = d.explanation || indicatorData.explanation || '';
                            const ma20Match = explanation.match(/MA20\((\d+\.\d+)\)/);
                            const ma50Match = explanation.match(/MA50\((\d+\.\d+)\)/);
                            
                            if (ma20Match && ma50Match) {
                                ma20Values.push(parseFloat(ma20Match[1]));
                                ma50Values.push(parseFloat(ma50Match[1]));
                            } else {
                                // å¦‚æœæ— æ³•æå–MAå€¼ï¼Œä½¿ç”¨ä»·æ ¼ä½œä¸ºè¿‘ä¼¼å€¼ï¼ˆè¿™æ ·è‡³å°‘å›¾è¡¨èƒ½æ˜¾ç¤ºï¼‰
                                ma20Values.push(price * 0.99); // MA20é€šå¸¸ç•¥ä½äºå½“å‰ä»·æ ¼
                                ma50Values.push(price * 0.96); // MA50é€šå¸¸æ›´ä½
                            }
                        }
                    }
                }
            });
            
            // è®¡ç®—Yè½´èŒƒå›´
            const allValues = [...sp500Values, ...ma20Values, ...ma50Values].filter(v => !isNaN(v));
            const minY = Math.min(...allValues);
            const maxY = Math.max(...allValues);
            const yRange = maxY - minY;
            const paddedMinY = minY - yRange * 0.02;
            const paddedMaxY = maxY + yRange * 0.02;
            
            // è·å–æœ€æ–°çš„æƒ…ç»ªçŠ¶æ€ç”¨äºèƒŒæ™¯é¢œè‰²
            const latestSentiment = sentiments[sentiments.length - 1];
            let backgroundColor = 'rgba(255, 255, 255, 0.1)'; // é»˜è®¤èƒŒæ™¯
            
            if (latestSentiment === 'optimistic') {
                backgroundColor = 'rgba(39, 174, 96, 0.1)'; // ç»¿è‰²èƒŒæ™¯
            } else if (latestSentiment === 'neutral') {
                backgroundColor = 'rgba(243, 156, 18, 0.1)'; // é»„è‰²èƒŒæ™¯
            } else if (latestSentiment === 'pessimistic') {
                backgroundColor = 'rgba(231, 76, 60, 0.1)'; // çº¢è‰²èƒŒæ™¯
            }
            
            // åˆ›å»ºèƒŒæ™¯æ³¨é‡Š
            const annotations = {
                backgroundZone: {
                    type: 'box',
                    yMin: paddedMinY,
                    yMax: paddedMaxY,
                    backgroundColor: backgroundColor,
                    borderWidth: 0,
                    borderColor: 'transparent',
                    xMin: 0,
                    xMax: dates.length - 1,
                    z: -1
                }
            };
            
            // åˆ›å»ºChart.jsé…ç½®
            const chartConfig = {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [
                        {
                            label: 'S&P 500',
                            data: sp500Values,
                            borderColor: '#2c3e50',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointBackgroundColor: '#2c3e50',
                            pointBorderColor: 'white',
                            pointBorderWidth: 2,
                            pointHoverRadius: 6,
                            pointHoverBackgroundColor: '#e74c3c',
                            pointHoverBorderColor: 'white',
                            pointHoverBorderWidth: 2
                        },
                        {
                            label: 'MA20',
                            data: ma20Values,
                            borderColor: '#3498db',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 2,
                            pointBackgroundColor: '#3498db',
                            pointBorderColor: 'white',
                            pointBorderWidth: 1,
                            borderDash: [5, 5]
                        },
                        {
                            label: 'MA50',
                            data: ma50Values,
                            borderColor: '#e67e22',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 2,
                            pointBackgroundColor: '#e67e22',
                            pointBorderColor: 'white',
                            pointBorderWidth: 1,
                            borderDash: [10, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                font: {
                                    size: 10
                                },
                                usePointStyle: true,
                                padding: 10
                            }
                        },
                        title: { display: false },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    return tooltipItems[0].label;
                                },
                                label: function(tooltipItem) {
                                    const datasetLabel = tooltipItem.dataset.label;
                                    const value = tooltipItem.formattedValue;
                                    return `${datasetLabel}: ${value}`;
                                },
                                afterBody: function(tooltipItems) {
                                    const index = tooltipItems[0].dataIndex;
                                    const sentiment = sentiments[index];
                                    if (sentiment) {
                                        return [`æƒ…ç»ª: ${getSentimentLabel(sentiment)}`];
                                    }
                                    return [];
                                }
                            }
                        },
                        annotation: {
                            annotations: annotations
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: { 
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)',
                                lineWidth: 1
                            },
                            ticks: {
                                maxRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 5,
                                font: {
                                    size: 10
                                },
                                color: '#666'
                            }
                        },
                        y: {
                            display: true,
                            grid: { 
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)',
                                lineWidth: 1
                            },
                            suggestedMin: paddedMinY,
                            suggestedMax: paddedMaxY,
                            ticks: {
                                font: {
                                    size: 10
                                },
                                color: '#666'
                            }
                        }
                    },
                    elements: {
                        point: { radius: 2 }
                    },
                    animation: {
                        duration: 1000
                    }
                }
            };
            
            // åˆ›å»ºå›¾è¡¨
            ctx.chart = new Chart(ctx, chartConfig);
        }
    </script>
</body>
</html>